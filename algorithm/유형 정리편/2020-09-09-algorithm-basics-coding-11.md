---
layout: post
title:  그래프 이론 with 파이썬
subtitle:   그래프 이론 with 파이썬
categories: algorithm
tags: algorithm-basics
comments: true
# header-img:
---
* 
{:toc}

## 1. 이미 배운 내용 정리
---
여기서는 지금까지 배우지 않았던 그래프 알고리즘을 추가로 다룰 것이다. 이전에 배운 DFS/BFS와 최단 경로에서 다룬 내용은 모두 그래프 알고리즘의 한 유형으로 볼 수 있다. 알고리즘 문제를 접했을 때 '서로 다른 개체(혹은 객체)가 연결되어 있다'는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올려야 한다. 가령 여러 개의 도시들의 연결되어 있다는 문제같이 말이다.
그래프 자료구조 중에서 트리 자료구조는 다양한 알고리즘에서 사용되므로 꼭 기억하자. 다익스트라 최단 경로 알고리즘에서는 우선순위 큐가 사용되었고 우선순위 큐를 구현하기 위해 최소 힙, 최대 힙을 이용할 수 있었다. 최소 힙은 항상 부모 노드가 자식 노드보다 크기가 작은 자료구조로서 트리 자료구조에 속한다. 트리 자료구조는 부모에서 자식으로 내려오는 계층적인 모델에 속한다. 그래프와 트리 자료구조를 비교하면 다음과 같다.  

비고|그래프|트리
---|---|---
방향성|방향 혹은 무방향 그래프|방향그래프
순환성|순환 및 비순환|비순환
루트 노드 존재 여부|없음|있음
노드간 관계성|부모와 자식 관계 없음|부모와 자식 관계
모델의 종류|네트워크 모델|계층 모델

또한 그래프의 구현 방법은 2가지 방식이 존재한다. 두 방식은 메모리와 속도 측면에서 구별되는 특징을 가진다.  
+ 인접 행렬 : 2차원 배열을 사용
+ 인접 리스트 : 리스트를 사용

노드의 개수가 V, 간선의 개수가 E인 그래프를 생각해보자. 인접 행렬을 이용하느 방식은 간선 정보를 저장하기 위해서 O(V^2)만큼의 메모리 공간이 필요하다. 반면에 인접 리스트를 이용할 때는 간선의 개수만큼인 O(E)만큼만 메모리 공간이 필요하다. 또한 인접 행렬은 특정한 노드 A에서 다른 특정한 노드 B로 이어진 간선의 비용을 O(1)의 시간으로 즉시 알 수 있다는 장점이 있으며, 반면에 인접 리스트를 이용할 때는 최악의 경우 O(V)만큼의 시간이 소요된다.  
다익스트라 최단 경로 알고리즘의 경우 인접 리스트를 이용하는 방식을 사용했고 플로이드 워셜 알고리즘은 인접 행렬을 이용하는 방식을 사용했다. 여기서 알아두어야 할 점은 어떤 문제를 만나든 메모리와 시간을 염두에 두고 알고리즘을 선택해서 구현해야 한다는 것이다. 예를 들어 최단 경로를 찾아야 하는 문제가 출제되었을 때, 노드의 개수가 적은 경우에는 플로이드 워셜 알고리즘을 이용할 수 있고 노드와 간선의 개수가 모두 많은 경우에는 우선순위 큐를 이용하는 다익스트라 알고리즘을 이용하면 유리하다. 이제부터는 기타 그래프 알고리즘을 알아보자.  
<br>

## 2. 서로소 집합
---
수학에서 서로소 집합이란 공통 원소가 없는 두 집합을 의미한다. 예를 들어 {1,2}와 {3,4}는 서로소 관계이다. 서로소 집합 자료구조란 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조라고 할 수 있다. 서로소 집합 자료구조는 union과 find 2개의 연산으로 조작할 수 있다. 따라서 서로소 집합 자료구조는 union-find 자료구조라고도 한다.  
+ union(합집합) : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
+ find(찾기) : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산

서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용하여 집합을 표현하는데 서로소 집합 정보(합집합 연산)가 주어졌을 때 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산 알고리즘은 다음과 같다.  
1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A,B를 확인한다.
  + A와 B의 루트 노드 A', B'를 각각 찾는다.
  + A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 한다)
2. 모든 union(합집합) 연산을 처리할 때까지 1번 과정을 반복한다.

실제로 구현할 때는 A'와 B'중에서 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 많으므로 이 방식을 따르도록 구현하자.
```python
import sys
input = sys.stdin.readline

# 특정 원소가 속합 집합 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면 루트 노드 찾을때까지 재귀 호출
    if parent[x] != x:
        # 재귀적으로 찾은 루트 노드를 부모 테이블에 갱신 : 경로 압축 기법
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합 합치기
def union(parent, x, y):
    a = find_parent(parent, x)
    b = find_parent(parent, y)
    if a > b:
        parent[a] = b
    else:
        parent[b] = a
    
# 노드와 간선 개수
v,e = map(int,input().split())
# 부모노드 위치 저장하는 테이블
parent=[0]*(v+1)

# 첫 시작은 각 노드의 부모 노드는 자기 자신
for i in range(1,v+1):
    parent[i]=i

# union 연산
# 간선의 정보를 입력
for i in range(e):
    a,b = map(int,input().split())
    union(parent,a,b)

# 각 원소가 속한 집합 출력
for i in range(1,v+1):
    print(find_parent(parent,i),end=" ")

print()

# 부모 테이블 출력
for i in range(1,v+1):
    print(parent[i],end=" ")
```
<br>

### 시간 복잡도
노드의 개수가 V개이고, 최대 V-1개의 union 연산과 M개의 find 연산이 가능할 때, 경로 압축 방법을 적용한 시간 복잡도는 O( V + M (1 + log(밑 2-M/V) (V) ) )이라고 알려져 있다.  
<Br>

### 서로소 집합을 활용한 사이클 판별
사이클이란 어떤 정점에서 시작해서 다시 자신에게 돌아오는 경로가 있다면 이를 사이클이 발생했다고 한다. 서로소 집합은 __무방향 그래프 내에서 사이클 판별할 때 사용__ 할 수 있다는 특징이 있다.  
앞서 union 연산은 큰 번호가 작은 번호를 부모노드로 가리키면서 그래프에서의 간선으로 표현될 수 있다고 했다. 따라서 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것만으로도 사이클을 판별할 수 있다. 알고리즘은 다음과 같다.  
1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
  + 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.
  + 루트 노드가 서로 같다면 사이클이 발생한 것이다.
2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.

루트 노드가 서로 같다면 사이클이 발생한 것이라고 했다. 왜 그럴까? union 연산을 수행하기 위해서 간선의 연결되어 있는 두 개의 노드를 받을 것이다. 그 뜻은 두 개의 노드가 간선으로 연결되어 있다는 것이다. 그런데 그 두 노드의 루트노드가 같다는 것은 루트 노드를 통해서 상대 노드로 이동할 수 있다는 것이다. 즉, 사이클을 형성한다는 것이다.
```python
import sys
input = sys.stdin.readline

# 특정 원소가 속합 집합 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면 루트 노드 찾을때까지 재귀 호출
    if parent[x] != x:
        # 재귀적으로 찾은 루트 노드를 부모 테이블에 갱신 : 경로 압축 기법
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합 합치기
def union(parent, x, y):
    a = find_parent(parent, x)
    b = find_parent(parent, y)
    if a > b:
        parent[a] = b
    else:
        parent[b] = a
    
# 노드와 간선 개수
v,e = map(int,input().split())
# 부모노드 위치 저장하는 테이블
parent=[0]*(v+1)

# 첫 시작은 각 노드의 부모 노드는 자기 자신
for i in range(1,v+1):
    parent[i]=i

cycle = False
# union 연산
# 간선의 정보를 입력
for i in range(e):
    a,b = map(int,input().split())
    if find_parent(parent,a) == find_parent(parent,b):
        cycle = True
        break
    union(parent,a,b)

if cycle:
    print("사이클 발생")
else :
    print("사이클이 발생하지 않음")
```
<br>

## 3. 신장 트리와 크루스칼 알고리즘
---
### 신장 트리
신장 트리는 그래프 알고리즘 문제로 자주 출제되는 문제 유형이다. 신장 트리란 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다. 이때 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 성립 조건이기도 하다. 그래서 이러한 그래프를 신장 트리라고 하는 것이다.  
<br>

### 크루스칼 알고리즘
다양한 문제 상황에서 가능한 최소한 비용으로 신장 트리를 찾아야 할 때가 있다. 예를 들어 N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 전체 도시가 서로 연결될 수 있게 도로를 설치하는 경우의 최소한의 비용으로 설치하는 방법처럼 말이다. 이처럼 신장 트리 중에서 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘을 최소 신장 트리 알고리즘이라고 한다. 대표적인 최소 신장 트리 알고리즘으로 크루스칼 알고리즘이 있다.  
크루스칼 알고리즘을 사용하면 가장 적은 비용으로 모든 노드를 연결할 수 있는데 크루스칼 알고리즘은 그리디 알고리즘으로 분류된다. 먼저 모든 간선에 대하여 정렬을 수행한 뒤에 가장 거리가 짧은 간선부터 집합에 포함시키면 된다. 이때 사이클이 발생하는 간선의 경우, 집합에 포함시키지 않는다. 알고리즘은 다음과 같다.  
1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
+ 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
+ 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
3. 모든 간선에 대하여 2번 과정을 반복한다.

최소 신장 트리는 일종의 트리 자료구조이므로, 최종적으로 신장 트리에 포함되는 간선의 개수가 (노드의 개수 -1)과 같다는 특징이 있다. 핵심 원리는 가장 거리가 짧은 간선부터 차례대로 집합에 추가하면 된다는 점과 사이클을 발생시키는 간선은 제외하고 연결하는 점이라는 것을 기억하자.  
```python
import sys
input = sys.stdin.readline

def find_parent(parent,x):
    if parent[x] != x:
        parent[x]= find_parent(parent,parent[x])
    return parent[x]

def union(parent,x,y):
    a = find_parent(parent,x)
    b = find_parent(parent,y)
    if a>b:
        parent[a]=b
    else :
        parent[b]=a

# 노드와 간선 개수
v,e = map(int,input().split())

# 루트 노트 리스트
parent=[0]*(v+1)

# 최소 신장 트리의 간선과 최소 비용
edges =[]
result=0

# 처음에는 각자 자기 자신을 루트 노드로
for i in range(1,v+1):
    parent[i]=i

# 모든 간선 정보 입력
for _ in range(e):
    # 정렬을 위해 cost를 맨 처음으로 받음
    # 비용과 a노드와 b노드 사이에 있는 간선
    a, b, cost = map(int,input().split())
    edges.append((cost,a,b))

# cost 순으로 정렬
edges.sort()

for edge in edges:
    cost, a, b = edge
    # 루트노드가 다르면 연결이 안되있다는 뜻
    if find_parent(parent,a) != find_parent(parent,b):
        union(parent,a,b)
        result += cost
    # 루트노드가 같으면 이미 연결되있으므로 무시

print(result)
```
<br>

#### 시간 복잡도
크루스칼 알고리즘은 간선의 개수가 E개일 때, O(ElogE)의 시간 복잡도를 가진다. 왜냐하면 크루스칼 알고리즘에서 시간이 가장 오래 걸리는 부분이 간선을 정렬하는 작업이며, E개의 데이터를 정렬했을 때의 시간 복잡도는 O(ElogE)이기 때문이다. 크루스칼 내부에서 사용되는 서로소 집합 알고리즘의 시간 복잡도는 정렬 알고리즘의 시간 복잡도보다 작으므로 무시한다.  

<br>

## 4. 위상 정렬
---
위상 정렬을 정렬 알고리즘의 일종이다. 위상 정렬은 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘이다. 조금 더 이론적으로 설명하면, 위상 정렬이란 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것이다. 예시로는 선수과목을 고려한 학습 순서 설정을 들 수 있겠다.  
위상 정렬 알고리즘을 살펴보기 전에, 먼저 진입차수를 알아야 한다. 진입차수란 특정한 노드로 들어오는 간선의 개수를 의미한다. 예시로 고급 알고리즘을 듣기 위해서 알고리즘을 들어야 하고 알고리즘을 듣기 위해서는 자료구조를 들어야 한다고 하자. 그렇다면 고급 알고리즘은 2개의 선수 과목을 가지고 있기 때문에 진입차수가 2개이고 알고리즘은 1개의 선수 과목을 가지고 있기에 1개의 진입차수가 있는 것이다. 구체적인 알고리즘은 다음과 같다.  
1. 진입차수가 0인 노드를 큐에 넣는다.
2. 큐가 빌 때까지 다음 과정을 반복한다.
    + 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
    + 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

이때 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있다. 다시 말해 큐에서 원소가 V번 추출되기 전에 큐가 비어버리면 사이클이 발생한 것이다. 사이클이 존재하는 경우 사이클에 포함되어 있는 원소 중에서 어떠한 원소도 큐에 들어가지 못하기 때문이다. 다만 기본적으로 위상 정렬 문제에서는 사이클이 발생하지 않는다고 명시하는 경우가 더 많으므로 여기서는 고려하지 않도록 하자.  
```python
# 방향성이 있는 그래프
import sys
from collections import deque

def topology_sort():
    # 수행 결과를 담을 리스트
    result =[]
    q = deque()

    # 처음 시작할 때 진입차수가 0인 노드를 큐에 삽입
    for i in range(1,v+1):
        if indegree[i]==0:
            q.append(i)
    # 빌 때까지 반복
    while q:
        idx = q.popleft()
        result.append(idx)
        for i in graph[idx]:
            indegree[i]-=1
            if indegree[i]==0:
                q.append(i)

    # 위상 정렬 수행 결과 출력
    for i in result:
        print(i,end=" ")

input = sys.stdin.readline

# 노드 간선의 개수
v,e = map(int,input().split())

# 그래프 정보 리스트와 진입차수 리스트
graph=[[] for i in range(v+1)]
indegree = [0]*(v+1)

# 간선 정보 입력
for _ in range(e):
    a,b = map(int,input().split())
    graph[a].append(b)
    indegree[b]+=1

topology_sort()
```
위상 정렬의 답안은 여러 가지가 될 수 있다는 특징이 있다. 만약에 한 단계에서 큐에 들어가는 원소가 2개 이상인 경우가 있다면, 여러 가지 답이 존재하게 된다. 큐에 들어가는 순서에 따라 답안이 달라지기 때문이다.  
<br>

### 시간 복잡도
위상 정렬의 시간 복잡도는 O(V+E)이다. 위상 정렬을 수행할 때는 차례대로 모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거해야 한다. 결과적으로 노드와 간선을 모두 확인한다는 측면에서 O(V+E)의 시간이 소요되는 것이다.  
<br>

## 5. 실전 문제
---
### 문제 : 팀 결성
학교에서 학생들에게 0번부터 N번까지의 번호를 부여했다. 처음에는 모든 학생이 서로 다른 팀으로 구분되어, 총 N+1개의 팀이 존재한다. 이때 선생님은 '팀 합치기 연산'과 '같은 팀 여부 확인 연산'을 사용할 수 있다.
1. 팀 합치기 연산은 두 팀을 합치는 연산이다.
2. 같은 팀 여부 확인 연산은 특정한 두 학생이 같은 팀에 속하는지를 확인하는 연산이다.

선생님이 M개의 연산을 수행할 수 있을 때, 같은 팀 여부 확인 연산에 대한 연산 결과를 출력하는 프로그램을 작성하시오.  
__입력 조건__  
+ 첫째 줄에 N,M이 주어진다. M은 입력으로 주어지는 연산 개수이다.
+ 다음 M개의 줄에는 각각의 연산이 주어진다.
+ 팀 합치기 연산은 0 a b 형태로 주어진다. 이는 a번 학생과 b번 학생이 속한 팀을 합친다는 의미이다.
+ 같은 팀 여부 확인 연산은 1 a b 형태로 주어진다. 이는 a번 학생과 b번 학생이 같은 팀에 속해있는지를 확인 하는 연산이다.
+ a,b는 모두 N이하의 양의 정수이다.

__출력 조건__  
+ 같은 팀 여부 확인 연산에 대하여 한 줄에 하나씩 YES 혹은 NO로 결과를 출력한다.

```
입력 예시
7 8
0 1 3
1 1 7
0 7 6
1 7 1
0 3 7
0 4 2
0 1 1
1 1 1

출력 예시
NO
NO
YES
```

#### 풀이
```python
import sys

def find_parent(parent,x):
    if parent[x] != x:
        parent[x]=find_parent(parent,parent[x])
    return parent[x]

def union(parent,x,y):
    a = find_parent(parent,x)
    b = find_parent(parent,y)
    if a>b:
        parent[a]=b
    else :
        parent[b]=a

input = sys.stdin.readline

n,m = map(int,input().split())
parent=[0]*(n+1)

for i in range(n+1):
    parent[i]=i

for _ in range(m):
    num, a, b = map(int,input().split())
    if num == 0:
        union(parent,a,b)
    else :
        if find_parent(parent,a) == find_parent(parent,b):
            print('YES')
        else :
            print('NO')
```
<br>

### 문제 : 도시 분할 계획
마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 그리고 길마다 길을 유지하는데 드는 유지비가 있다.  
마을의 이장은 마을을 2개의 분리된 마을로 분할할 계획을 세우고 있다. 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 마을에는 집이 하나 이상 있어야 한다.  
마을 안에 길이 너무 많아 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다. 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 이것을 구하는 프로그램을 작성하시오.  
__입력 조건__  
+ 첫째 줄에 집의 개수N, 길의 개수M이 주어진다. N은 2이상 100,000만 이하인 정수고 M은 1이상 1,000,000 이하인 정수이다.
+ 둘째 줄부터 M줄에 걸쳐 길의 정보가 A, B, C 3개의 정수로 공백으로 구분되어 주어지는데 A번 집과 B번 집을 연결하는 길의 유지비가 C(1 <= C<= 1,000)라는 뜻이다.

__출력 조건__  
+ 첫째 줄에 길을 없애고 남은 유지비 합의 최솟값을 출력

```
입력예시
7 12
1 2 3
1 3 2
3 2 1
2 5 2
3 4 4
7 3 6
5 1 5
1 6 2
6 4 1
6 5 3
4 5 3
6 7 4
출력예시
8
```

#### 풀이
```python
import sys

def find_parent(parent,x):
    if parent[x] != x:
        parent[x]=find_parent(parent,parent[x])
    return parent[x]

def union(parent,x,y):
    a = find_parent(parent,x)
    b = find_parent(parent,y)
    if a>b:
        parent[a]=b
    else :
        parent[b]=a

input = sys.stdin.readline

n,m = map(int,input().split())
parent=[0]*(n+1)
result=0

for i in range(n+1):
    parent[i]=i

graphs=[]

for _ in range(m):
    a,b,c = map(int,input().split())
    graphs.append((c,a,b))

graphs.sort()

for graph in graphs: 
    cost ,a ,b = graph         
    if find_parent(parent,a) != find_parent(parent,b) :         
        union(parent,a,b)
        result += cost
        last = cost

# 마지막에 추가한 비용 제거
print(result-last)
```
크루스칼 알고리즘을 이용해서 최소 비용 트리 만든다. 마지막에 제일 비용이 비싼 것이 연결되면서 최소 비용 트리가 완성될텐데, 이때 제일 비싼 비용 합치지 않는다면 마을이 2개로 나뉜다는 아이디어로 접근했다.  
<br>

### 문제 : 커리큘럼
캐릭터가 총 N개의 강의를 듣고자 한다. 모든 강의는 1번부터 N번까지의 번호를 가진다. 또한 동시에 여러 개의 강의를 들을 수 있다고 가정한다. 예를 들어 N=3일 때, 3번 강의의 선수강 강의로 1번과 2번 강의가 있고, 1번과 2번의 강의는 선수강 강의가 없다고 가정하자. 1번 강의가 30시간, 2번 강의가 20시간, 3번 강의가 40시간이라고 했을때, 3번 강의를 수강하기까지의 최소 시간은 70시간이 되는 것이다.(동시에 수강할 수 있기 때문)  
캐릭터가 듣고자 하는 N개의 강의 정보가 주어졌을 때, N개의 강의에 대하여 수강하기까지 걸리는 최소 시간을 각각 출력하는 프로그램을 작성하시오.  
__입력 조건__  
+ 첫째 줄에 캐릭터가 듣고자 하는 강의의 수N(1 <= N <= 500)
+ 다음 N개의 줄에는 각 강의의 강의 시간과 그 강의를 듣기 위해 먼저 들어야 하는 강의들의 번호가 자연수로 주어지며, 각 자연수는 공백으로 구분한다. 이때 강의 시간은 100,000 이하의 자연수이다.
+ 각 강의 번호는 1부터 N까지로 구성되면 각 줄은 -1로 끝난다.

__출력 조건__  
+ N개의 강의에 대하여 수강하기 까지 걸리는 최소 시간을 한 줄에 하나씩 출력한다.

```
입력 예시
5
10 -1
10 1 -1
4 1 -1
4 3 1 -1
3 3 -1
출력 예시
10
20
14
18
17
```

#### 풀이
```python
import sys
import copy
from collections import deque

def topology_sort():
    q = deque()
    ans = copy.deepcopy(time)

    # 진입차수 0인것 담기
    for i in range(1, n + 1):
        if in_cnt[i] == 0:
            q.append(i)

    # 만약 싸이클 존재 여부를 확인해야 한다면
    # for문으로 정점의 개수만큼 돌리고 정점 개수 전에 q가 비어버리면 싸이클이 도는 것으로 판단
    while q:
        idx = q.popleft()
        for i in graph[idx]:
            in_cnt[i] -= 1 # 진입 차수 제거
            ans[i] = max(ans[i], ans[idx] + time[i]) # 시간 정보
            if in_cnt[i] == 0: # 진입차수가 0이면 추가
                q.append(i)
    return ans

input = sys.stdin.readline

n = int(input())
graph = [[] for _ in range(n + 1)] # 간선 정보
time = [0] * (n + 1) # 시간
in_cnt = [0] * (n + 1) # 진입 차수

for i in range(1, n + 1):
    ls = list(map(int, input().split()))
    # 시간과 집입 차수 입력
    time[i] = ls[0]
    in_cnt[i] = len(ls) - 2

    # 간선 입력
    for j in ls[1:-1]:
        graph[j].append(i)

result = topology_sort()
for i in result[1:]:
    print(i)
```
커리큘럼은 결국 선수강과목부터 체크해야된다. 즉, 진입차수가 0인 것부터 차례대로 계산하여 최종적으로 해당 과목의 최소 시간이 나오는 것이다. 따라서 진입차수가 0인 것부터 큐에 넣고 빼내면서 연결된 간선을 삭제하고 다시 진입차수가 0인 것을 넣는 것을 반복한다.  
문제에서 여러 강의를 동시에 수강하는 것이 가능하다고 주어졌으므로 result에 들어가는 값은 선수강 과목 중에서 시간이 더 긴 것을 넣어야 한다.  
코드를 보면 알겠지만 result와 time을 같은 줄에 넣는 것이 있다. result를 단순히 copy를 사용한다면 result는 리스트이기 때문에 대입 연산 과정에서 값이 변경되는 문제가 발생할 수도 있기 때문에 만약의 경우를 우려해 deepcopy를 사용했다.  
__위 코드에서 기억할 테크닉__  
+ 리스트의 값을 복제해야 할 때는 만일의 경우를 대비해 deepcopy를 사용하자.
+ for x in data[1:-1]: 1번 인덱스부터 마지막의 한 칸 뒤까지. -1은 마지막 칸을 이지만 [:x]는 x인덱스 전까지를 의미한다.

<br>

---
__본 포스팅은 '이것이 코딩 테스트다 with 파이썬'을 읽고 공부한 내용을 바탕으로 작성하였습니다.__
